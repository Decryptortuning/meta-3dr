#!/bin/sh

PATH=/sbin:/bin:/usr/sbin:/usr/bin

ROOT_MOUNT="/rootfs/"

BOOT_DISK="/dev/mmcblk0"
BOOT_PART_PREFIX="p"

part_dev() {
	echo "${BOOT_DISK}${BOOT_PART_PREFIX}$1"
}

set_boot_disk_from_root() {
	case "$ROOT_DEVICE" in
		/dev/mmcblk[0-9]*p[0-9]*)
			BOOT_DISK="${ROOT_DEVICE%p*}"
			BOOT_PART_PREFIX="p"
			;;
		/dev/mmcblk[0-9]*)
			BOOT_DISK="$ROOT_DEVICE"
			BOOT_PART_PREFIX="p"
			;;
		/dev/sd[a-z][0-9]*)
			BOOT_DISK="${ROOT_DEVICE%%[0-9]*}"
			BOOT_PART_PREFIX=""
			;;
		/dev/sd[a-z])
			BOOT_DISK="$ROOT_DEVICE"
			BOOT_PART_PREFIX=""
			;;
		/dev/nvme*n[0-9]p[0-9]*)
			BOOT_DISK="${ROOT_DEVICE%p*}"
			BOOT_PART_PREFIX="p"
			;;
	esac
}

# Copied from initramfs-framework. The core of this script probably should be
# turned into initramfs-framework modules to reduce duplication.
udev_daemon() {
	OPTIONS="/sbin/udev/udevd /sbin/udevd /lib/udev/udevd /lib/systemd/systemd-udevd"

	for o in $OPTIONS; do
		if [ -x "$o" ]; then
			echo $o
			return 0
		fi
	done

	return 1
}

_UDEV_DAEMON=`udev_daemon`

mmc_sector_size() {
	DISK_NAME="${BOOT_DISK##*/}"
	SECTOR_SIZE=`cat "/sys/block/${DISK_NAME}/queue/hw_sector_size" 2>/dev/null`
	[ -z "$SECTOR_SIZE" ] && SECTOR_SIZE=512
	echo "$SECTOR_SIZE"
}

part_info() {
	PART_NUM="$1"
	parted -sm -- "$BOOT_DISK" unit s print 2>/dev/null | awk -F: -v p="$PART_NUM" '$1==p {print}'
}

part_end_sector() {
	part_info "$1" | awk -F: '{gsub("s","",$3); print $3}'
}

part_size_sectors() {
	part_info "$1" | awk -F: '{gsub("s","",$4); print $4}'
}

wait_for_part() {
	PART_NUM="$1"
	i=0
	while [ $i -lt 50 ]; do
		[ -b "$(part_dev "$PART_NUM")" ] && return 0
		usleep 100000 2>/dev/null || sleep 0.1
		i=$((i + 1))
	done
	return 1
}

early_setup() {
    mkdir -p /proc
    mkdir -p /sys
    mkdir -p /dev
    mount -t proc proc /proc
    mount -t sysfs sysfs /sys
    mount -t devtmpfs none /dev
#    mknod -m 600 /dev/initctl p

    # support modular kernel
    modprobe isofs 2> /dev/null

    mkdir -p /run
    mkdir -p /var/run

    #$_UDEV_DAEMON --daemon
    #udevadm trigger --action=add
}

read_args() {
    [ -z "$CMDLINE" ] && CMDLINE=`cat /proc/cmdline`
    for arg in $CMDLINE; do
        optarg=`expr "x$arg" : 'x[^=]*=\(.*\)'`
        case $arg in
            root=*)
                ROOT_DEVICE=$optarg ;;
            factoryreset=*)
                FORCE_FACTORY_RESET=$optarg;;
        esac
    done
}

boot_live_root() {
    # Watches the udev event queue, and exits if all current events are handled
    #udevadm settle --timeout=3 --quiet
    #killall "${_UDEV_DAEMON##*/}" 2>/dev/null

    mount -n --move /proc ${ROOT_MOUNT}/proc
    mount -n --move /sys ${ROOT_MOUNT}/sys
    mount -n --move /dev ${ROOT_MOUNT}/dev

    echo "Switching root"
    cd "$ROOT_MOUNT" || fatal "Failed to chdir to new root ($ROOT_MOUNT)"

    # IMPORTANT: /init is PID 1. Use exec so /sbin/init becomes PID 1.
    # Use util-linux switch_root semantics (no BusyBox-only -c flag).
    exec switch_root "$ROOT_MOUNT" /sbin/init
    fatal "switch_root failed"
}

fatal() {
    msg="$1"

    for c in "$CONSOLE" "${ROOT_MOUNT}/dev/console" "/dev/console" "/dev/kmsg"; do
        [ -n "$c" ] || continue
        if echo "$msg" >"$c" 2>/dev/null; then
            echo >"$c" 2>/dev/null || true
            break
        fi
    done

    if command -v sh >/dev/null 2>&1; then
        exec sh
    elif [ -x /bin/sh ]; then
        exec /bin/sh
    elif [ -x /bin/busybox ]; then
        exec /bin/busybox sh
    fi

    exec /bin/bash
}

create_partitions()
{
    echo "Creating partitions"
    P1_END=`part_end_sector 1`
    P1_SIZE=`part_size_sectors 1`
    if [ -z "$P1_END" ] || [ -z "$P1_SIZE" ]; then
        fatal "Unable to determine GOLDEN partition size"
    fi

    P2_START=$((P1_END + 1))
    P2_END=$((P2_START + P1_SIZE - 1))

    P3_START=$((P2_END + 1))
    SECTOR_SIZE=`mmc_sector_size`
    RWFS_SECTORS=$(( (100 * 1024 * 1024 + SECTOR_SIZE - 1) / SECTOR_SIZE ))
    P3_END=$((P3_START + RWFS_SECTORS - 1))

    P4_START=$((P3_END + 1))

    parted -s -- "$BOOT_DISK" unit s mkpart primary fat32 ${P2_START}s ${P2_END}s
    parted -s -- "$BOOT_DISK" unit s mkpart primary ext2 ${P3_START}s ${P3_END}s
    parted -s -- "$BOOT_DISK" unit s mkpart primary ext2 ${P4_START}s 100%

    wait_for_part 2 || fatal "Partition 2 did not appear"
    wait_for_part 3 || fatal "Partition 3 did not appear"
    wait_for_part 4 || fatal "Partition 4 did not appear"
    
    echo "Formatting LATEST"
    mkfs.vfat "$(part_dev 2)" -n LATEST
    echo "Formatting RWFS"
    mkfs.ext3 -F "$(part_dev 3)" -L RWFS -q
    echo "Formatting LOG"
    mkfs.ext3 -F "$(part_dev 4)" -L LOG -q
}

remove_partitions()
{
    parted -s -- "$BOOT_DISK" rm 2
    parted -s -- "$BOOT_DISK" rm 3
    parted -s -- "$BOOT_DISK" rm 4
}

setScreenUpdating() {
    #Set up the Artoo serial port, send a slip-encoded message
    #indicating that we've started the update.
    stty -F /dev/ttymxc1 115200 cs8 -cstopb -parity -crtscts
    echo -en "\xC0\x12\x00\xC0" > /dev/ttymxc1
}

setLedUpdating() {
    #Blink the LED crazy fast
    echo timer >> /sys/class/leds/user2/trigger
    echo 50 >> /sys/class/leds/user2/delay_on
    echo 50 >> /sys/class/leds/user2/delay_off
}

setLedDone() {
    echo none >> /sys/class/leds/user2/trigger
}

checkRwfs() {
    fsck.ext3 -y "$(part_dev 3)"
    if [ $? -ge 4 ]; then
        echo "Error detected on RWFS partition"
        setLedUpdating
        umount "$(part_dev 3)"
        mkfs.ext3 -F "$(part_dev 3)" -L RWFS -q
        setLedDone
    fi
}

checkLog() {
    fsck.ext3 -y "$(part_dev 4)"
    if [ $? -ge 4 ]; then
        echo "Error detected on LOG partition, repartitioning"
        setLedUpdating
        umount "$(part_dev 4)"
        parted -s -- "$BOOT_DISK" rm 4
        P3_END=`part_end_sector 3`
        if [ -z "$P3_END" ]; then
            fatal "Unable to determine RWFS end sector"
        fi
        P4_START=$((P3_END + 1))
        parted -s -- "$BOOT_DISK" unit s mkpart primary ext2 ${P4_START}s 100%
        wait_for_part 4 || fatal "Partition 4 did not appear"
        mkfs.ext3 -F "$(part_dev 4)" -L LOG -q
        setLedDone
        # this should not trigger an "update done" screen
        mkdir -f /mnt/log/updates
        mount "$(part_dev 4)" /mnt/log
        mkdir /mnt/log/updates
        touch /mnt/log/updates/READY
        umount /mnt/log
    fi
}

mount_and_boot() {
    mkdir $ROOT_MOUNT
    mknod /dev/loop0 b 7 0 2>/dev/null
    mkdir -p /mnt/ro_rootfs
    mkdir -p /mnt/rw_rootfs
    mkdir -p /mnt/boot
    
    #Check the boot partitions
    fsck.vfat -y "$(part_dev 1)"
    if [ $? -ge 4 ]; then
        echo "Error detected on GOLDEN partition"
    fi
    fsck.vfat -y "$(part_dev 2)"
    if [ $? -ge 4 ]; then
        echo "Error detected on LATEST partition"
    fi

    #Mount the boot partition
    echo "Using $ROOT_DEVICE as the boot partition"
    mount -o ro $ROOT_DEVICE /mnt/boot

    #Mount the read-only squashfs partition
    mount -o ro /mnt/boot/*.squashfs /mnt/ro_rootfs
    
    #Check the rw partition
    checkRwfs

    #mount the read-write partition
    mount "$(part_dev 3)" /mnt/rw_rootfs

    #Mount the overlayfs union partition (replacing legacy AUFS)
    modprobe overlay 2>/dev/null || true
    mkdir -p /mnt/rw_rootfs/upper
    rm -rf /mnt/rw_rootfs/work
    mkdir -p /mnt/rw_rootfs/work
    mount -t overlay overlay \
        -o lowerdir=/mnt/ro_rootfs,upperdir=/mnt/rw_rootfs/upper,workdir=/mnt/rw_rootfs/work \
        $ROOT_MOUNT

    #Move all those mount points
    mkdir -p $ROOT_MOUNT/mnt/rootfs.ro $ROOT_MOUNT/mnt/rootfs.rw $ROOT_MOUNT/mnt/boot
    mount --move /mnt/boot $ROOT_MOUNT/mnt/boot
    mount --move /mnt/ro_rootfs $ROOT_MOUNT/mnt/rootfs.ro
    mount --move /mnt/rw_rootfs $ROOT_MOUNT/mnt/rootfs.rw

    # boot the image
    boot_live_root
}

factory_reset() {

    setScreenUpdating
    setLedUpdating
    
    #delete partions 2-4,
    #Recreate new partitions
    remove_partitions
    create_partitions

    #Reflash u-boot if its file exists
    mkdir -p /mnt/golden
    mount "$(part_dev 1)" /mnt/golden
    if [ -e /mnt/golden/u-boot.imx ]; then
        dd if=/mnt/golden/u-boot.imx of="$BOOT_DISK" bs=512 seek=2
    fi

    setLedDone

    umount /mnt/golden
    sync
    /sbin/shutdown -r -n now
}

echo "******************** INITRD ********************"
early_setup
read_args
set_boot_disk_from_root
[ -z "$CONSOLE" ] && CONSOLE="/dev/console"

#if there is no LATEST partition, assume that we need to create
#the RWFS and LOG partitions as well
if [ ! -e "$(part_dev 2)" ]; then
    echo "No LATEST partition, creating partition scheme"
    #Set the LED to let the user know its formatting
    setScreenUpdating
    setLedUpdating

    create_partitions

    setLedDone

else
    #If there was a factory reset request from u-boot, handle it here
    echo "Factory reset: " $FORCE_FACTORY_RESET
    if [ $FORCE_FACTORY_RESET == 1 ]; then
        echo "Factory reset from GPIO request"
        factory_reset
    fi

    checkLog

    echo "Checking for an update..."
    #See if there is an update file we should be using
    mkdir /mnt/log
    mount "$(part_dev 4)" /mnt/log
    if [ -e /mnt/log/updates/UPDATE ]; then
        echo "Update requested checking for update file"

        rm -f /mnt/log/updates/READY
        sync
        setScreenUpdating
        setLedUpdating

        for file in $(find /mnt/log/updates/ -type f -name "*.tar.gz" | sort); do
            echo "Found file $file".
            latestFile=$file
        done

        #Is there an update file?
        if [ -z $latestFile ]; then
            echo "No update tarball, restarting"
            rm /mnt/log/updates/UPDATE
            echo "No update tarball" >> /mnt/log/updates/UPDATEFAILED

            setLedDone

            sync
            /sbin/shutdown -r -n now
        fi

        #Check the MD5sum of the update tarball
        if [ ! -e ${latestFile}.md5 ]; then
            echo "No MD5 file for update tarball, removing and restarting"
            rm $latestFile
            rm /mnt/log/updates/UPDATE
            echo "MD5 Missing" >> /mnt/log/updates/UPDATEFAILED

            setLedDone

            sync
            /sbin/shutdown -r -n now
        fi

        cd /mnt/log/updates
        md5res=`md5sum -c ${latestFile}.md5 | awk '{print $2}'`
        if [ $md5res == 'OK' ]; then
            echo "MD5 OK, proceeding"
        else
            echo "MD5 failure, removing file and rebooting"
            rm $latestFile
            rm ${latestFile}.md5
            rm /mnt/log/updates/UPDATE
            echo "MD5 Failed" >> /mnt/log/updates/UPDATEFAILED

            setLedDone

            sync
            /sbin/shutdown -r -n now
        fi
        cd ~/

        #Mount the LATEST partition and overwrite everything in it
        echo "Formatting LATEST"
        mkfs.vfat "$(part_dev 2)" -n LATEST
        echo "Updating LATEST with $latestFile"
        mkdir /mnt/latest
        mount "$(part_dev 2)" /mnt/latest
        tar -xf $latestFile -C /mnt/latest/

        #if there is a u-boot.imx, flash it to the SD card
        if [ -e /mnt/latest/u-boot.imx ]; then
            dd if=/mnt/latest/u-boot.imx of="$BOOT_DISK" bs=512 seek=2
        fi

        #We're all done here
        rm /mnt/log/updates/UPDATE

        # Check and see if theres a settings reset also requested
        if [ -e /mnt/log/updates/RESETSETTINGS ]; then
            echo "Settings reset also requested."
            #Unmount active partitions, delete partions 3-4,
            #Recreate new partitions 3 and 4
            umount /mnt/log /mnt/latest

            parted -s -- "$BOOT_DISK" rm 3
            parted -s -- "$BOOT_DISK" rm 4
            P2_END=`part_end_sector 2`
            if [ -z "$P2_END" ]; then
                fatal "Unable to determine LATEST end sector"
            fi
            P3_START=$((P2_END + 1))
            SECTOR_SIZE=`mmc_sector_size`
            RWFS_SECTORS=$(( (100 * 1024 * 1024 + SECTOR_SIZE - 1) / SECTOR_SIZE ))
            P3_END=$((P3_START + RWFS_SECTORS - 1))
            P4_START=$((P3_END + 1))
            parted -s -- "$BOOT_DISK" unit s mkpart primary ext2 ${P3_START}s ${P3_END}s
            parted -s -- "$BOOT_DISK" unit s mkpart primary ext2 ${P4_START}s 100%
            wait_for_part 3 || fatal "Partition 3 did not appear"
            wait_for_part 4 || fatal "Partition 4 did not appear"
            mkfs.ext3 -F "$(part_dev 3)" -L RWFS -q
            mkfs.ext3 -F "$(part_dev 4)" -L LOG -q
        fi

        echo "Done updating, restarting"

        setLedDone

        sync
        /sbin/shutdown -r -n now

    elif [ -e /mnt/log/updates/FACTORYRESET ]; then
        echo "Factory reset requested."
        umount /mnt/log
        factory_reset

    elif [ -e /mnt/log/updates/RESETSETTINGS ]; then
        echo "Settings reset requested."
        
        #Set the LED to let the user know its formatting
        setScreenUpdating
        setLedUpdating
        
        #Unmount active partitions, delete partions 3-4,
        #Recreate new partitions 3 and 4
        umount /mnt/log

        parted -s -- "$BOOT_DISK" rm 3
        parted -s -- "$BOOT_DISK" rm 4
        P2_END=`part_end_sector 2`
        if [ -z "$P2_END" ]; then
            fatal "Unable to determine LATEST end sector"
        fi
        P3_START=$((P2_END + 1))
        SECTOR_SIZE=`mmc_sector_size`
        RWFS_SECTORS=$(( (100 * 1024 * 1024 + SECTOR_SIZE - 1) / SECTOR_SIZE ))
        P3_END=$((P3_START + RWFS_SECTORS - 1))
        P4_START=$((P3_END + 1))
        parted -s -- "$BOOT_DISK" unit s mkpart primary ext2 ${P3_START}s ${P3_END}s
        parted -s -- "$BOOT_DISK" unit s mkpart primary ext2 ${P4_START}s 100%
        wait_for_part 3 || fatal "Partition 3 did not appear"
        wait_for_part 4 || fatal "Partition 4 did not appear"
        mkfs.ext3 -F "$(part_dev 3)" -L RWFS -q
        mkfs.ext3 -F "$(part_dev 4)" -L LOG -q

        setLedDone

        sync
        /sbin/shutdown -r -n now
    else
        echo "No update available, booting."
    fi
    umount /mnt/log
fi

#Boot the squashfs
mount_and_boot
